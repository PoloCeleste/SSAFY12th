# Classes

## 상속

### 개요

#### 상속 `Inheritance`

- 기존 클래스의 속성과 메서드를 물려받아 새로운 하위 클래스를 생성하는 것

#### 상속이 필요한 이유

1. 코드 재사용
   - 상속을 통해 기존 클래스의 속성과 메서드를 재사용할 수 있음
   - 새로운 클래스를 작성할 때 기존 클래스의 기능을 그대로 활용할 수 있으며, 중복된 코드를 줄일 수 있음
2. 계층 구조
   - 상속을 통해 클래스들 간의 계층 구조를 형성할 수 있음
   - 부모 클래스와 자식 클래스 간의 관계를 표현하고, 더 구체적인 클래스를 만들 수 있음
3. 유지 보수의 용이성
   - 상속을 통해 기존 클래스의 수정이 필요한 경우, 해당 클래스만 수정하면 되므로 유지 보수가 용이해짐
   - 코드의 일관성을 유지하고, 수정이 필요한 범위를 최소화할 수 있음

### 클래스 상속

#### 상속 없이 구현 하는 경우

- 학생/교수 정보를 나타내기 어려움

  ```py
  class Person:
      def __init__(self, name, age):
          self.name = name
          self.age = age

      def talk(self):
          print(f'반갑습니다. {self.name}입니다.')


  s1 = Person('김학생', 23)
  s1.talk() # 반갑습니다. 김학생입니다.

  p1 = Person('박교수', 59)
  p1.talk() # 반갑습니다. 박교수입니다.
  ```

- 교수/학생 클래스로 분리 했지만 메서드가 중복으로 정의될 수 있음

  ```py
  class Professor:
      def __init__(self, name, age, department):
          self.name = name
          self.age = age
          self.department = department

      def talk(self): # 중복
          print(f'반갑습니다. {self.name}입니다.')

  class Student:
      def __init__(self, name, age, gpa):
          self.name = name
          self.age = age
          self.gpa = gpa

      def talk(self): # 중복
          print(f'반갑습니다. {self.name}입니다.')
  ```

#### 상속을 사용한 계층구조 변경

```py
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def talk(self):  # 메서드 재사용
        print(f'반갑습니다. {self.name}입니다.')


class Professor(Person):
    def __init__(self, name, age, department):
        self.name = name
        self.age = age
        self.department = department


class Student(Person):
    def __init__(self, name, age, gpa):
        self.name = name
        self.age = age
        self.gpa = gpa


p1 = Professor('박교수', 49, '컴퓨터공학과')
s1 = Student('김학생', 20, 3.5)

# 부모 Person 클래스의 talk 메서드를 활용
p1.talk() # 반갑습니다. 박교수입니다.

# 부모 Person 클래스의 talk 메서드를 활용
s1.talk() # 반갑습니다. 김학생입니다.
```
